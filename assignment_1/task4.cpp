#include <iostream>   // Подключение библиотеки для ввода и вывода (cout, endl)
#include <cstdlib>    // Подключение библиотеки для работы с rand() и srand()
#include <ctime>      // Подключение библиотеки для получения текущего времени (time)
#include <chrono>     // Подключение библиотеки для точного замера времени
#include <omp.h>      // Подключение библиотеки OpenMP для параллельных вычислений

#ifdef _WIN32         // Проверка: если программа компилируется под Windows
#include <windows.h>  // Подключение заголовка Windows API
#endif                // Конец условной компиляции

int main() {          // Главная функция программы — точка входа

#ifdef _WIN32
    // Устанавливает кодировку UTF-8 для корректного вывода кириллицы в Windows-консоль
    SetConsoleOutputCP(CP_UTF8);

    // Устанавливает кодировку UTF-8 для корректного ввода с клавиатуры
    SetConsoleCP(CP_UTF8);
#endif

    const int SIZE = 5'000'000;   // Размер массива — 5 миллионов элементов

    // Динамическое выделение памяти под массив из SIZE целых чисел
    int* array = new int[SIZE];

    // Инициализация генератора случайных чисел текущим временем
    std::srand(static_cast<unsigned>(std::time(nullptr)));

    // Последовательное заполнение массива случайными числами от 1 до 100
    for (int i = 0; i < SIZE; i++) {   // Цикл по всем элементам массива
        array[i] = std::rand() % 100 + 1; // Генерация случайного числа в диапазоне [1; 100]
    }

    /* ================== ПОСЛЕДОВАТЕЛЬНЫЙ РАСЧЕТ СРЕДНЕГО ================== */

    // Запуск таймера перед последовательным вычислением среднего значения
    auto start_seq = std::chrono::high_resolution_clock::now();

    // Переменная для хранения суммы элементов массива (long long — защита от переполнения)
    long long sum_seq = 0;

    // Последовательный подсчет суммы элементов массива
    for (int i = 0; i < SIZE; i++) {   // Проход по всему массиву
        sum_seq += array[i];           // Добавление текущего элемента к сумме
    }

    // Вычисление среднего значения (приведение к double для точности)
    double average_seq = static_cast<double>(sum_seq) / SIZE;

    // Остановка таймера после последовательного вычисления
    auto end_seq = std::chrono::high_resolution_clock::now();

    // Вычисление времени выполнения последовательного алгоритма в миллисекундах
    std::chrono::duration<double, std::milli> time_seq = end_seq - start_seq;

    /* ================== ПАРАЛЛЕЛЬНЫЙ РАСЧЕТ СРЕДНЕГО (OpenMP) ================== */

    // Запуск таймера перед параллельным вычислением среднего значения
    auto start_par = std::chrono::high_resolution_clock::now();

    // Переменная для хранения общей суммы элементов массива
    long long sum_par = 0;

    // Параллельный цикл OpenMP с редукцией для корректного суммирования
    #pragma omp parallel for reduction(+:sum_par)
    for (int i = 0; i < SIZE; i++) {   // Итерации цикла распределяются между потоками
        sum_par += array[i];           // Каждый поток добавляет к своей локальной сумме
    }

    // Вычисление среднего значения для параллельной версии
    double average_par = static_cast<double>(sum_par) / SIZE;

    // Остановка таймера после параллельного вычисления
    auto end_par = std::chrono::high_resolution_clock::now();

    // Вычисление времени выполнения параллельного алгоритма в миллисекундах
    std::chrono::duration<double, std::milli> time_par = end_par - start_par;

    /* ================== ВЫВОД РЕЗУЛЬТАТОВ ================== */

    // Вывод результата последовательной версии и времени выполнения
    std::cout << "Последовательное среднее: " << average_seq
              << ", Время: " << time_seq.count() << " мс" << std::endl;

    // Вывод результата параллельной версии и времени выполнения
    std::cout << "Параллельное среднее (OpenMP): " << average_par
              << ", Время: " << time_par.count() << " мс" << std::endl;

    // Освобождение ранее выделенной динамической памяти
    delete[] array;

    // Завершение программы с кодом успешного выполнения
    return 0;
}
